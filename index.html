<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GD Level Extractor + Save Code Generator</title>
</head>
<body>
  <h1>Geometry Dash Level Extractor</h1>
  <input type="file" id="f" accept=".xml,.gmd" />
  <pre id="out"></pre>

  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script>
    let globalKeyMap = {};

    function base64Clean(b) {
      b = b.replace(/\s/g, "").replace(/-/g, "+").replace(/_/g, "/");
      while (b.length % 4) b += "=";
      return b;
    }

    function atobArr(b64) {
      const s = atob(base64Clean(b64));
      const arr = new Uint8Array(s.length);
      for (let i = 0; i < s.length; i++) arr[i] = s.charCodeAt(i);
      return arr;
    }

    function mapLevelSpeed(floatSpeed) {
      if (floatSpeed === 0.5 || floatSpeed === 0.6) return 1;
      switch (floatSpeed) {
        case 1: return 2;
        case 2: return 3;
        case 3: return 4;
        case 4: return 5;
        default: return 2;
      }
    }

    function mapGameMode(raw) {
      switch (raw) {
        case 0: return 1;
        case 1: return 2;
        case 2: return 4;
        case 3: return 3;
        case 4: return 5;
        default: return 5;
      }
    }

    function rgbTo24Bit(r, g, b) {
      return (r << 16) + (g << 8) + b;
    }

    function normalizeRotation(deg) {
      return ((deg % 360) + 360) % 360;
    }

    const extraRotations = {
      1: null, 2: 0, 3: 0, 4: 0, 5: 90, 6: 90, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0,
      12: 0, 13: 0, 14: 0, 15: 0, 16: 0, 17: 0, 18: 0, 19: 180, 20: 180, 21: 180,
      22: 180, 23: 180, 24: 180, 25: 180, 26: 180, 27: 0, 28: 0, 29: 180, 30: 180,
      31: 0, 32: 0, 33: 0, 34: 0, 35: 0, 36: 0, 37: 0, 38: 180, 39: 180, 40: 180,
      41: 0, 42: 0, 43: 0, 44: 0, 45: 0, 46: 0, 47: 0, 48: 0, 49: 0
    };

    const yOffsets = {
      10: -8, 12: 9, 13: 12.5, 14: -4, 15: 13, 17: 8, 18: 10.5, 28: 12.5,
      33: 12, 36: 13, 46: -7, 47: -7, 48: -7, 49: -7
    };

    const idMap = {
      1: 2, 83: 3, 2: 4, 3: 5, 4: 6, 502: 6, 5: 7, 6: 8, 7: 9,
      1903: 10, 40: 10, 8: 11, 39: 12, 1715: 13, 9: 13, 18: 14,
      35: 15, 36: 16, 17: 17, 41: 18, 13: 19, 12: 20, 111: 21,
      200: 22, 201: 23, 202: 24, 203: 25, 1334: 26, 1333: 27,
      1332: 28, 11: 29, 10: 30, 31: 31, 84: 32, 67: 33, 1022: 34,
      141: 35, 140: 36, 1330: 37, 47: 38, 660: 39, 1755: 40,
      899: 41, 29: 41, 30: 41, 1705: 42, 88: 42, 1706: 43, 89: 43,
      1707: 44, 98: 44, 1329: 45, 68: 46, 66: 47, 62: 48, 65: 49
    };

    document.getElementById("f").onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const xml = new DOMParser().parseFromString(reader.result, "text/xml");
        const ks = xml.querySelectorAll("k");
        const allKeyValues = {};
        for (let i = 0; i < ks.length; i++) {
          const key = ks[i].textContent;
          const val = ks[i].nextElementSibling?.textContent ?? '';
          allKeyValues[key] = val;
        }

        globalKeyMap = allKeyValues;
        const k4 = allKeyValues["k4"];
        if (!k4) return out.textContent = "No k4 key found.";

        let decompressed;
        try {
          decompressed = pako.inflate(atobArr(k4), { to: 'string' });
        } catch (err) {
          return out.textContent = "Decompression failed: " + err;
        }

        const sections = decompressed.split("|");
        let bgColor = 0, groundColor = 0;

        const bgMatch = sections[0]?.match(/1_(\d+)_2_(\d+)_3_(\d+)/);
        if (bgMatch) bgColor = rgbTo24Bit(...bgMatch.slice(1, 4).map(Number));

        const grMatch = sections[1]?.match(/1_(\d+)_2_(\d+)_3_(\d+)/);
        if (grMatch) groundColor = rgbTo24Bit(...grMatch.slice(1, 4).map(Number));

        const entries = decompressed.split(";").filter(e => e.trim());
        const objs = [];

        for (let i = 1; i < entries.length; i++) {
          const parts = entries[i].split(",");
          let rawId = null, x = null, y = null, rot = 90, key4 = 0;
          let key7 = 0, key8 = 0, key9 = 0, key10 = 0, key23 = 0;

          for (let j = 0; j + 1 < parts.length; j += 2) {
            const key = parts[j];
            const val = parts[j + 1];
            if (key === "1") rawId = parseInt(val);
            else if (key === "2") x = parseFloat(val);
            else if (key === "3") y = parseFloat(val);
            else if (key === "4") key4 = parseInt(val);
            else if (key === "6") rot = parseFloat(val) + 90;
            else if (key === "7") key7 = parseInt(val);
            else if (key === "8") key8 = parseInt(val);
            else if (key === "9") key9 = parseInt(val);
            else if (key === "10") key10 = parseFloat(val);
            else if (key === "23") key23 = parseInt(val);
          }

          if (!(rawId in idMap)) continue;
          let mappedId = idMap[rawId];

          // Handle special swap for 47 â†” 49
          if (key4 === 1) {
            if (mappedId === 47) mappedId = 49;
            else if (mappedId === 49) mappedId = 47;
          }

          let rotation = normalizeRotation(rot);
          if (key4 === 1 && extraRotations[mappedId] != null) {
            rotation = normalizeRotation(rotation + extraRotations[mappedId]);
          }

          let adjX = x + 15;
          let adjY = y + 165;
          if (yOffsets[mappedId]) adjY += yOffsets[mappedId];

          const roundedX = Math.round(adjX / 30) * 30;
          const roundedY = Math.round(adjY / 30) * 30;
          const gridX = roundedX / 30;
          const gridY = roundedY / 30;
          const offsetX = Math.floor(adjX - roundedX);
          const offsetY = Math.floor(adjY - roundedY);

          if (gridX < 1 || gridY < 1) continue;

          const obj = {
            id: mappedId,
            rotation,
            gridX,
            gridY,
            offsetX,
            offsetY,
            editObject: 0
          };

          if (mappedId === 41) {
            let type = (rawId === 29) ? 1 : (rawId === 30) ? 2 : (key23 === 1000) ? 1 : (key23 === 1001) ? 2 : null;
            obj.editObject = {
              type,
              duration: key10,
              color: rgbTo24Bit(key7, key8, key9)
            };
          }

          objs.push(obj);
        }

        const speedMatch = decompressed.match(/kA4,(\d+)/);
        const speed = mapLevelSpeed(speedMatch ? parseInt(speedMatch[1]) : 0);

        const gameModeMatch = decompressed.match(/kA2,(\d+)/);
        const gamemode = mapGameMode(gameModeMatch ? parseInt(gameModeMatch[1]) : 0);

        let songKey = parseInt(globalKeyMap["k8"] ?? 0) + 1;
        if (songKey > 7) songKey = 7;
        const song = `N${songKey}`;

        function encodeRLE(array) {
          let result = [];
          let i = 0;
          while (i < array.length) {
            let count = 1;
            while (i + count < array.length && array[i] === array[i + count]) count++;
            result.push(`${array[i]},(${count})`);
            i += count;
          }
          return result.join("");
        }

        const gridWidth = 3125;
        const gridHeight = 64;
        const totalTiles = gridWidth * gridHeight;

        const blockGrid = Array(totalTiles).fill().map(() => []);
        const rotGrid = Array(totalTiles).fill().map(() => []);
        const editGrid = Array(totalTiles).fill().map(() => []);
        const offsetGrid = Array(totalTiles).fill().map(() => []);

        objs.forEach(obj => {
          const index = (Math.floor(obj.gridY) - 1) * gridWidth + (Math.floor(obj.gridX) - 1);
          if (index < 0 || index >= totalTiles) return;
          blockGrid[index].push(obj.id);
          rotGrid[index].push(obj.rotation / 90);
          offsetGrid[index].push(`${obj.offsetX}&${obj.offsetY}`);
          editGrid[index].push(obj.editObject !== 0
            ? `${obj.editObject.color}s${obj.editObject.duration}t${obj.editObject.type}` : 0);
        });

        for (let i = 0; i < totalTiles; i++) {
          blockGrid[i].unshift(1);
          rotGrid[i].unshift(1);
          editGrid[i].unshift(0);
          offsetGrid[i].unshift("0&0");
        }

        const blockCode = encodeRLE(blockGrid.map(b => b.join(",")));
        const rotCode = "R" + encodeRLE(rotGrid.map(r => r.join(",")));
        const bgCode = "B" + bgColor;
        const grCode = "G" + groundColor;
        const sCode = `S${gamemode}${speed}`;
        const editCode = "E" + encodeRLE(editGrid.map(e => e.join(",")));
        const musicCode = `M${song}`;
        const offsetCode = "O" + encodeRLE(offsetGrid.map(o => o.join(",")));

        out.textContent = `${blockCode}${rotCode}${bgCode}${grCode}${sCode}${editCode}${musicCode}${offsetCode}`;
      };
      reader.readAsText(file);
    };

    const out = document.getElementById("out");
  </script>
</body>
</html>
